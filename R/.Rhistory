load("/Users/davidhodgson/Dropbox/academia/PhD/ptmc/performance/R/data.RData")
knitr::opts_chunk$set(echo = TRUE)
age_lim <- c(0, 2)
# Birth rate per days (mu) and the population of England (2017 ONS)
dem = list(
mu = 1860.564,
pop = 58744600
)
#  POLYMOD data for contact matrices
data(polymod) # Get the polymod
poly <- contact_matrix(polymod, countries = "United Kingdom", age.limits = age_lim, symmetric = TRUE)
library(BayesianTools)
library("Rcpp")       # For c++ intergration
library("RcppEigen")  # Ditto
library("coda")  # Ditto
library("tidyverse")
library("ptmc")
library(gridExtra)
library('socialmixr')
no_chains <- 10
age_lim <- c(0, 2)
# Birth rate per days (mu) and the population of England (2017 ONS)
dem = list(
mu = 1860.564,
pop = 58744600
)
#  POLYMOD data for contact matrices
data(polymod) # Get the polymod
poly <- contact_matrix(polymod, countries = "United Kingdom", age.limits = age_lim, symmetric = TRUE)
# Get the observation (cleaned)
#obsdata <- clean_data(age_lim) can clean data according to any age stratification
obsdata <- read.table("./data/RSV_RSDM_pos_trim.txt")
age_lim <- c(0, 2)
# Birth rate per days (mu) and the population of England (2017 ONS)
dem = list(
mu = 1860.564,
pop = 58744600
)
#  POLYMOD data for contact matrices
data(polymod) # Get the polymod
poly <- contact_matrix(polymod, countries = "United Kingdom", age.limits = age_lim, symmetric = TRUE)
# Get the observation (cleaned)
#obsdata <- clean_data(age_lim) can clean data according to any age stratification
obsdata <- read.table("../data/RSV_RSDM_pos_trim.txt")
age_lim <- c(0, 2)
# Birth rate per days (mu) and the population of England (2017 ONS)
dem = list(
mu = 1860.564,
pop = 58744600
)
#  POLYMOD data for contact matrices
data(polymod) # Get the polymod
poly <- contact_matrix(polymod, countries = "United Kingdom", age.limits = age_lim, symmetric = TRUE)
# Get the observation (cleaned)
#obsdata <- clean_data(age_lim) can clean data according to any age stratification
obsdata <- read.table("../rdms/RSV_RSDM_pos_trim.txt")
# List of data
data = list(
obsdata=obsdata,
poly=poly,
dem=dem,
agegroup=age_lim
)
# Import the log likelihood function
sourceCpp("../src/ll_func_c.cpp") #ensure c+11 is enabled
age_lim <- c(0, 2)
# Birth rate per days (mu) and the population of England (2017 ONS)
dem = list(
mu = 1860.564,
pop = 58744600
)
#  POLYMOD data for contact matrices
data(polymod) # Get the polymod
poly <- contact_matrix(polymod, countries = "United Kingdom", age.limits = age_lim, symmetric = TRUE)
# Get the observation (cleaned)
#obsdata <- clean_data(age_lim) can clean data according to any age stratification
obsdata <- read.table("../rdms/RSV_RSDM_pos_trim.txt")
# List of data
data = list(
obsdata=obsdata,
poly=poly,
dem=dem,
agegroup=age_lim
)
# Import the log likelihood function
sourceCpp("./src/ll_func_c.cpp") #ensure c+11 is enabled
# Create parameters with upper, lower prior (upper, lower prior)
Pars <- data.frame(matrix(vector(), 13, 3,
dimnames=list(c(), c("lower", "upper", "best"))),
stringsAsFactors=F)
Pars$lower <- rep(-100, 13)
Pars$upper <- rep(100, 13)
Pars$best <- rep(0, 13)
rownames(Pars) <- c("ga0", "om", "a", "b", "phi", "psi", "I1", "I2", "I3", "d1", "ep1", "ep2", "alpha")
# Get the log likelihood
llikelihood <- function(params){
ll <- eval_ll_cpp(data$obsdata, data$poly$matrix, data$dem, data$agegroup, params)
if (ll == -Inf) # This is to stop infinite log likelihoods gettings stuck
ll = -1000000
return(ll)
}
# Get the log priors (density and samplers)
density = function(params){
p1 = 0
for (i in 1:13)
{
p1 = p1 + dlogis(params[i], location = 0, scale = 1, log = TRUE)
}
return(p1)
}
sampler = function(n=1){
s1 = rlogis(13, location = 0, scale = 1)
return(s1)
}
prior <- createPrior(density = density, sampler = sampler,lower = rep(-10, 13), upper = rep(10, 13))
# Create Bayesian Setup, this can be used in the Parallel tempering function
bayesianSetup <- createBayesianSetup(llikelihood, prior, names = rownames(Pars))
model <- list(
par_names =  c("ga0", "om", "a", "b", "phi", "psi", "I1", "I2", "I3", "d1", "ep1", "ep2", "alpha"),
# Generate the initial step of Markov chain
gen_init = function() {
s1 <- rlogis(13, location = 0, scale = 1)
s1
},
# Evaluate the log prior
eval_lpr = function(params) {
p1 = 0
for (i in 1:13)
{
p1 <- p1 + dlogis(params[i], location = 0, scale = 1, log = TRUE)
}
p1
},
# Evaluate the log likelihood
eval_ll = function(data, params) {
eval_ll_cpp(data$obsdata, data$poly$matrix, data$dem, data$agegroup, params)
}
)
p
ggsave("../ms/figs/convPT.pdf", gelman.plot(outPT$mcmc) )
lpAll <- bind_rows(lpMH, lpAM, lpDezs,  outPT$lpost)
lpAll_conv <- lpAll %>% filter(sample_no>round(l/2))
p1 <- ggplot(lpAll, aes(x = sample_no, y = loglike)) +
geom_line(aes(color = c(mcmc,chain_no)), size = 0.2, alpha=0.8) +
theme_minimal()
p2 <- ggplot(lpAll_conv, aes(x = sample_no, y = loglike)) +
geom_line(aes(color = mcmc), size = 0.2, alpha=0.8) +
theme_minimal()
grid.arrange(p1, p2,  top="Parallel Tempering")
lpPT_conv <- outPT$lpost %>% filter(sample_no>round(10000/2))
p1 <- ggplot(outPT$lpost, aes(x = sample_no, y = log(-lpost))) +
geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
theme_minimal()  +  scale_y_continuous(name="Log(-LogLikelihoood)")  + theme(legend.position = "none") + scale_x_continuous(name="Step number")
p2 <- ggplot(lpPT_conv, aes(x = sample_no, y = log(-lpost))) +
geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
theme_minimal() +  scale_y_continuous(name="Log(-LogLikelihoood)", limits=c(8.06, 8.08))  + theme(legend.position = "none") + scale_x_continuous(name="Step number")
p <- grid.arrange(p1, p2,  top="Parallel Tempering")
ggsave("../ms/figs/llogPT.pdf", p)
l <- length(outAM[[1]]$chain[,14])
lpAM <- data.frame(loglike=log(-as.vector(sapply(c(1:no_chains), function(x) outAM[[x]]$chain[,14]))))
lpAM$chain_no <- as.vector(sapply(c(1:no_chains), function(x) rep(toString(x), l)))
lpAM$sample_no <- rep(1:l,no_chains)
lpAM$mcmc <- rep("AM", l*no_chains)
lpAM_conv <- lpAM %>% filter(sample_no>round(l/2))
p1 <- ggplot(lpAM, aes(x = sample_no, y = loglike)) +
geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
theme_minimal()  +  scale_y_continuous(name="log(-log(p($\psi$|D)))") + theme(legend.position = "none") + scale_x_continuous(name="Step number")
l <- length(outAM[[1]]$chain[,14])
lpAM <- data.frame(loglike=log(-as.vector(sapply(c(1:no_chains), function(x) outAM[[x]]$chain[,14]))))
lpAM$chain_no <- as.vector(sapply(c(1:no_chains), function(x) rep(toString(x), l)))
lpAM$sample_no <- rep(1:l,no_chains)
lpAM$mcmc <- rep("AM", l*no_chains)
lpAM_conv <- lpAM %>% filter(sample_no>round(l/2))
p1 <- ggplot(lpAM, aes(x = sample_no, y = loglike)) +
geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
theme_minimal()  +  scale_y_continuous(name="log(-log(p(\psi|D)))") + theme(legend.position = "none") + scale_x_continuous(name="Step number")
l <- length(outAM[[1]]$chain[,14])
lpAM <- data.frame(loglike=log(-as.vector(sapply(c(1:no_chains), function(x) outAM[[x]]$chain[,14]))))
lpAM$chain_no <- as.vector(sapply(c(1:no_chains), function(x) rep(toString(x), l)))
lpAM$sample_no <- rep(1:l,no_chains)
lpAM$mcmc <- rep("AM", l*no_chains)
lpAM_conv <- lpAM %>% filter(sample_no>round(l/2))
p1 <- ggplot(lpAM, aes(x = sample_no, y = loglike)) +
geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
theme_minimal()  +  scale_y_continuous(name="log(-log(p(psi|D)))") + theme(legend.position = "none") + scale_x_continuous(name="Step number")
p2 <- ggplot(lpAM_conv, aes(x = sample_no, y = loglike)) +
geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
theme_minimal() +  scale_y_continuous(name="log(-log(p(psi|D)))", limits=c(8.06, 8.08)) + theme(legend.position = "none") + scale_x_continuous(name="Step number")
p <- grid.arrange(p1, p2,  top="Adaptive Metropolis-Hastings")
ggsave("../ms/figs/llogAM.pdf", p)
l <- length(outMH[[1]]$chain[,14])
lpMH <- data.frame(loglike=log(-as.vector(sapply(c(1:no_chains), function(x) outMH[[x]]$chain[,14]))))
lpMH$chain_no <- as.vector(sapply(c(1:no_chains), function(x) rep(toString(x), l)))
lpMH$sample_no <- rep(1:l,no_chains)
lpMH$mcmc <- rep("Metropolis", l*no_chains)
lpMH_conv <- lpMH %>% filter(sample_no>round(l/2))
p1<- ggplot(lpMH, aes(x = sample_no, y = loglike)) +
geom_line(aes(color = chain_no), size = 0.15, alpha=0.8) +
theme_minimal() +  scale_y_continuous(name="log(-log(p(psi|D)))") + theme(legend.position = "none") + scale_x_continuous(name="Step number")
p2<- ggplot(lpMH_conv, aes(x = sample_no, y = loglike)) +
geom_line(aes(color = chain_no), size = 0.15, alpha=0.8) +
theme_minimal() +  scale_y_continuous(name="log(-log(p(psi|D)))", limits=c(8.06, 8.08)) + theme(legend.position = "none") + scale_x_continuous(name="Step number")
p <- grid.arrange(p1, p2,  top="Normal Metropolis-Hastings")
ggsave("../ms/figs/llogMH.pdf", p)
l <- length(outDezs[[1]][[3]][[1]][,14])
lpDezs <- data.frame(loglike=log(-as.vector(sapply(c(1:no_chains), function(x) outDezs[[x]][[3]][[1]][,14]))))
lpDezs$chain_no <- as.vector(sapply(c(1:no_chains), function(x) rep(toString(x), l)))
lpDezs$sample_no <- rep(1:l,no_chains)
lpDezs$mcmc <- rep("Dezs", l*no_chains)
lpDezs_conv <- lpDezs %>% filter(sample_no>round(l/2))
p1 <- ggplot(lpDezs, aes(x = sample_no, y = loglike)) +
geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
theme_minimal()  +  scale_y_continuous(name="log(-log(p(psi|D)))") + theme(legend.position = "none") + scale_x_continuous(name="Step number")
p2 <- ggplot(lpDezs_conv, aes(x = sample_no, y = loglike)) +
geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
theme_minimal() +  scale_y_continuous(name="log(-log(p(psi|D)))", limits=c(8.06, 8.08)) + theme(legend.position = "none") + scale_x_continuous(name="Step number")
p <- grid.arrange(p1, p2,  top="Differential Evolaution with snooker update")
ggsave("../ms/figs/llogDE.pdf", p)
lpPT_conv <- outPT$lpost %>% filter(sample_no>round(10000/2))
p1 <- ggplot(outPT$lpost, aes(x = sample_no, y = log(-lpost))) +
geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
theme_minimal()  +  scale_y_continuous(name="log(-log(p(psi|D)))")  + theme(legend.position = "none") + scale_x_continuous(name="Step number")
p2 <- ggplot(lpPT_conv, aes(x = sample_no, y = log(-lpost))) +
geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
theme_minimal() +  scale_y_continuous(name="log(-log(p(psi|D)))", limits=c(8.06, 8.08))  + theme(legend.position = "none") + scale_x_continuous(name="Step number")
p <- grid.arrange(p1, p2,  top="Parallel Tempering")
ggsave("../ms/figs/llogPT.pdf", p)
gelman.plot(outPT$mcmc, auto.layout = FALSE)
p<- gelman.plot(outPT$mcmc, auto.layout = FALSE)
plot(outPT$mcmc)
gelman.plot(outPT$mcmc)
gelman.plot(outPT$mcmc)
ploytout(PT$mcmc
)
ploytout(PT$mcmc)
plot(outPT$mcmc)
lpAll <- bind_rows(lpMH, lpAM, lpDezs,  outPT$lpost)
lpAll_conv <- lpAll %>% filter(sample_no>round(l/2))
p1 <- ggplot(lpAll, aes(x = sample_no, y = loglike)) +
geom_line(aes(color = c(mcmc,chain_no)), size = 0.2, alpha=0.8) +
theme_minimal()
p2 <- ggplot(lpAll_conv, aes(x = sample_no, y = loglike)) +
geom_line(aes(color = mcmc), size = 0.2, alpha=0.8) +
theme_minimal()
grid.arrange(p1, p2,  top="Parallel Tempering")
gelman.plot(outPT$mcmc)
