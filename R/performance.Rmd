---
title: "Performance comparison of PT with other mcmmc"
author: "David Hodgson"
date: "03/02/2020"
output: pdf_document
---

# 1. Setup 
# 1.1 Import dependencies
```{r dependencies}

library(Rcpp)       # For c++ intergration
library(BayesianTools)
library("RcppEigen")  # Ditto
library("coda")  # Ditto
library("tidyverse")
library("ptmc")
library(gridExtra)
library('socialmixr')
library(profvis)
library(reshape2)

no_chains <- 10

namesOfParameters <- c("ga0", "om", "a", "b", "phi", "psi", "I1", "I2", "I3", "d1", "ep1", "ep2", "alpha")

load("~/Dropbox/academia/PhD/ptmc/performance/R/dataNew.RData")

```


# 4. Plots to understand convergence
#4.1 Likelihood 
```{r}

l <- length(outMH[[1]]$chain[,14])
lpMH <- data.frame(loglike=log(-as.vector(sapply(c(1:no_chains), function(x) outMH[[x]]$chain[,14]))))
lpMH$chain_no <- as.vector(sapply(c(1:no_chains), function(x) rep(toString(x), l)))
lpMH$sample_no <- rep(1:l,no_chains)
lpMH$mcmc <- rep("Metropolis", l*no_chains)

lpMH_conv <- lpMH %>% filter(sample_no>round(l/2))

p1<- ggplot(lpMH, aes(x = sample_no, y = loglike)) + 
  geom_line(aes(color = chain_no), size = 0.15, alpha=0.8) +
  theme_minimal() +  scale_y_continuous(name="log(-log(p(psi|D)))", limits=c(8.09, 8.10))  + theme(legend.position = "none") + scale_x_continuous(name="Step number")

p2<- ggplot(lpMH_conv, aes(x = sample_no, y = loglike)) + 
  geom_line(aes(color = chain_no), size = 0.15, alpha=0.8) +
 theme_minimal() +  scale_y_continuous(name="log(-log(p(psi|D)))", limits=c(8.09, 8.10)) + theme(legend.position = "none") + scale_x_continuous(name="Step number")

p <- grid.arrange(p1, p2,  top="Standard Metropolis-Hastings")

ggsave("../ms/figs/llogMH.pdf", p)

```

```{r}

l <- length(outAM[[1]]$chain[,14])
lpAM <- data.frame(loglike=log(-as.vector(sapply(c(1:no_chains), function(x) outAM[[x]]$chain[,14]))))
lpAM$chain_no <- as.vector(sapply(c(1:no_chains), function(x) rep(toString(x), l)))
lpAM$sample_no <- rep(1:l,no_chains)
lpAM$mcmc <- rep("AM", l*no_chains)
lpAM_conv <- lpAM %>% filter(sample_no>round(l/2))

p1 <- ggplot(lpAM, aes(x = sample_no, y = loglike)) + 
  geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
  theme_minimal()  +  scale_y_continuous(name="log(-log(p(psi|D)))") + theme(legend.position = "none") + scale_x_continuous(name="Step number")

p2 <- ggplot(lpAM_conv, aes(x = sample_no, y = loglike)) + 
  geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) + 
  theme_minimal() +  scale_y_continuous(name="log(-log(p(psi|D)))", limits=c(8.09, 8.10)) + theme(legend.position = "none") + scale_x_continuous(name="Step number")


p <- grid.arrange(p1, p2,  top="Adaptive Metropolis-Hastings")

ggsave("../ms/figs/llogAM.pdf", p)


```

```{r}

l <- length(outDezs[[1]][[3]][[1]][,14])
lpDezs <- data.frame(loglike=log(-as.vector(sapply(c(1:no_chains), function(x) outDezs[[x]][[3]][[1]][,14]))))
lpDezs$chain_no <- as.vector(sapply(c(1:no_chains), function(x) rep(toString(x), l)))
lpDezs$sample_no <- rep(1:l,no_chains)
lpDezs$mcmc <- rep("Dezs", l*no_chains)

lpDezs_conv <- lpDezs %>% filter(sample_no>round(l/2))

p1 <- ggplot(lpDezs, aes(x = sample_no, y = loglike)) + 
  geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
  theme_minimal()  +  scale_y_continuous(name="log(-log(p(psi|D)))") + theme(legend.position = "none") + scale_x_continuous(name="Step number")

p2 <- ggplot(lpDezs_conv, aes(x = sample_no, y = loglike)) + 
  geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
  theme_minimal() +  scale_y_continuous(name="log(-log(p(psi|D)))", limits=c(8.09, 8.10)) + theme(legend.position = "none") + scale_x_continuous(name="Step number")

p <- grid.arrange(p1, p2,  top="Differential Evolution with snooker update")

ggsave("../ms/figs/llogDE.pdf", p)


```


```{r}


lpPT_conv <- outPT$lpost %>% filter(sample_no>round(0))

p1 <- ggplot(outPT$lpost, aes(x = sample_no, y = log(-lpost))) + 
  geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
  theme_minimal()  +  scale_y_continuous(name="log(-log(p(psi|D)))")  + theme(legend.position = "none") + scale_x_continuous(name="Step number")

p2 <- ggplot(lpPT_conv, aes(x = sample_no, y = log(-lpost))) +
  geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
  theme_minimal() +  scale_y_continuous(name="log(-log(p(psi|D)))", limits=c(8.09, 8.10))  + theme(legend.position = "none") + scale_x_continuous(name="Step number")
 
p <- grid.arrange(p1, p2,  top="Parallel Tempering")

ggsave("../ms/figs/llogPT.pdf", p)


```

# Plot acceptance rate

```{r}
acceptance <- outPT$acc %>% filter(chain_no==1)

acceptancerateAv <- c(mean(sapply(1:10, function(x) outMH[[x]]$acceptanceRate)),
mean(sapply(1:10, function(x) outAM[[x]]$acceptanceRate)),
mean(sapply(1:10, function(x) mean(1-rejectionRate(outDezs[[x]]$codaChain[[1]])))),
mean(acceptance$'acceptance rate'[1:9999]))

dfAcceptance <- data.frame('Average acceptance rate'=acceptancerateAv, mcmcSampler=factor(c("Normal","Adaptive","Differential Evolution","Parallel Tempering"),  c("Normal","Adaptive","Differential Evolution","Parallel Tempering")))

p <- ggplot(dfAcceptance, aes(x = mcmcSampler, y = Average.acceptance.rate)) +
        geom_bar(stat="identity")

ggsave("../ms/figs/acc.pdf", p)

```
 
Comparison of converged posteriors 
 
```{r}
logLogLikelihoodConvergeBoundary <- 8.115

# Filter for MH and AM 
getConvergedChains <- function(fullDataFrame, convergedDataFrame, nameOfSample){
  chainNumberConverged <- as.numeric(convergedDataFrame %>% filter(sample_no==convergedDataFrame[1,3]) %>% filter(loglike < logLogLikelihoodConvergeBoundary) %>% pull(chain_no))
  
  for (i in 1:length(chainNumberConverged))
    colnames(fullDataFrame[[chainNumberConverged[i]]]$chain) <- c(namesOfParameters, "LP", "LL", "LPr")
  
  convergedchains <- lapply(chainNumberConverged, function(x) melt(fullDataFrame[[x]]$chain[50001:99999,], c("sampleNo","parameter")))  
  convergedchains <- do.call(rbind, convergedchains)
  convergedchains <- cbind(convergedchains, sampler=rep(nameOfSample, nrow(convergedchains)))
  convergedchains
}

#filterMH <- getConvergedChains(outMH, lpMH_conv, "MH")
filterAM <- getConvergedChains(outAM, lpAM_conv, "AM")

# Filter for Dezs
chainNumberConvergedDezs <- as.numeric(lpDezs_conv %>% filter(sample_no==lpDezs_conv[1,3]) %>% filter(loglike < logLogLikelihoodConvergeBoundary) %>% pull(chain_no))
convergedchains <- lapply(chainNumberConvergedDezs, function(x) melt(outDezs[[x]]$chain[[1]][lpDezs_conv[1,3]:33333,], c("sampleNo","parameter")))  
convergedchains <- do.call(rbind, convergedchains)
filterDezs <- cbind(convergedchains, sampler=rep("DEzs", nrow(convergedchains)))


# Filter for PT
chainNumberConvergedPT <- as.numeric(lpPT_conv %>% filter(sample_no==lpPT_conv[1,3]) %>% filter(log(-lpost) < logLogLikelihoodConvergeBoundary) %>% pull(chain_no))
convergedchains <- lapply(chainNumberConvergedPT, function(x) melt(outPT$mcmc[[x]][lpPT_conv[1,3]:5000,], c("sampleNo","parameter")))  
convergedchains <- do.call(rbind, convergedchains)
filterPT <- cbind(convergedchains, sampler=rep("PT", nrow(convergedchains)))

filter <- filter(do.call(rbind, list(filterAM, filterDezs, filterPT)), parameter %in% namesOfParameters)

```

```{r}
namesOfParameters =  c("ga0", "om", "a", "b", "phi", "psi", "I1", "I2", "I3", "d1", "ep1", "ep2", "alpha")

p <- list()

for (i in 1:13)
{
  p[[i]] <- ggplot(filter(filter, parameter==namesOfParameters[i]), aes(x=value, color=sampler, fill=sampler)) + 
  geom_density(alpha=0.3) + 
  scale_color_manual(values=c("#00FF00", "#E69F00", "#56B4E9", "#B8181E")) +
  scale_fill_manual(values=c("#00FF00", "#E69F00", "#56B4E9", "#B8181E")) +
  labs(title=paste0("Posterior for ", namesOfParameters[i], sep="") ,x="Value", y = "Density") + 
    theme(text = element_text(size=1), title=element_text(size=1), legend.title = element_text( size=1), legend.text=element_text(size=1)) + 
    guides(shape = guide_legend(override.aes = list(size = 0.01)), color = guide_legend(override.aes = list(size = 0.01)))
}

pp <- grid.arrange(p[[1]], p[[2]], p[[3]], p[[4]], p[[5]], p[[6]], p[[7]], p[[8]], p[[9]], p[[10]], p[[11]], p[[12]], p[[13]], ncol=2)
ggsave("../ms/figs/comparPost.pdf", pp)

```

```{r}

p <- ggplot(filter, aes(x=value, color=sampler, fill=sampler)) + 
  geom_density(alpha=0.3) + 
  scale_color_manual(values=c("#00FF00", "#E69F00", "#56B4E9", "#B8181E")) +
  scale_fill_manual(values=c("#00FF00", "#E69F00", "#56B4E9", "#B8181E")) +
  labs(title=paste0("Posterior for ", namesOfParameters[i], sep="") ,x="Value", y = "Density") + 
    theme(text = element_text(size=5), title=element_text(size=7), legend.title = element_text( size=7), legend.text=element_text(size=7)) + 
    guides(shape = guide_legend(override.aes = list(size = 0.01)), color = guide_legend(override.aes = list(size = 0.01)))

p + facet_grid(parameter ~ .,  scales="free")
  

```

```{r}
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
````

```{r}

gelman.plot(outPT$mcmc)

```
