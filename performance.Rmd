---
title: "Performance comparison of PT with other mcmmc"
author: "David Hodgson"
date: "03/02/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1. Setup 
# 1.1 Import dependencies
```{r dependencies}

library(BayesianTools)
library("Rcpp")       # For c++ intergration
library("RcppEigen")  # Ditto
library("coda")  # Ditto
library("tidyverse")
library("ptmc")
library(gridExtra)

library('socialmixr')

source("./data/clean.R") # this is for cleaning if you wanted to try a different age range 
no_chains <- 10

```

1.2 Import data for the epidemic model
```{r download the data}

age_lim <- c(0, 2) 

# Birth rate per days (mu) and the population of England (2017 ONS)
dem = list(
  mu = 1860.564,
  pop = 58744600
)

#  POLYMOD data for contact matrices
data(polymod) # Get the polymod
poly <- contact_matrix(polymod, countries = "United Kingdom", age.limits = age_lim, symmetric = TRUE)

# Get the observation (cleaned)
#obsdata <- clean_data(age_lim) can clean data according to any age stratification
obsdata <- read.table("./data/RSV_RSDM_pos_trim.txt")

# List of data
data = list(
  obsdata=obsdata,
  poly=poly,
  dem=dem,
  agegroup=age_lim
)

# Import the log likelihood function
sourceCpp("./src/ll_func_c.cpp") #ensure c+11 is enabled

```

# 2. Define the models 
# 2.1 Define model for MCMC algorithms in via  Bayesian Tools package
```{r outline the model for BT}

# Create parameters with upper, lower prior (upper, lower prior)
Pars <- data.frame(matrix(vector(), 13, 3,
                dimnames=list(c(), c("lower", "upper", "best"))),
                stringsAsFactors=F) 
Pars$lower <- rep(-100, 13)
Pars$upper <- rep(100, 13)
Pars$best <- rep(0, 13)
rownames(Pars) <- c("ga0", "om", "a", "b", "phi", "psi", "I1", "I2", "I3", "d1", "ep1", "ep2", "alpha")

# Get the log likelihood
llikelihood <- function(params){
  ll <- eval_ll_cpp(data$obsdata, data$poly$matrix, data$dem, data$agegroup, params)
  if (ll == -Inf) # This is to stop infinite log likelihoods gettings stuck
    ll = -1000000
  
  return(ll)
}

# Get the log priors (density and samplers)
density = function(params){
  p1 = 0
  for (i in 1:13)
  {
    p1 = p1 + dlogis(params[i], location = 0, scale = 1, log = TRUE)
  }
return(p1)
}

sampler = function(n=1){
  s1 = rlogis(13, location = 0, scale = 1)
  return(s1)
}
prior <- createPrior(density = density, sampler = sampler,lower = rep(-10, 13), upper = rep(10, 13))

# Create Bayesian Setup, this can be used in the Parallel tempering function
bayesianSetup <- createBayesianSetup(llikelihood, prior, names = rownames(Pars))

```

2.2 Define model for PTMC algorithm via the ptmc package

```{r outline the model for PTMC}

model <- list(

  par_names =  c("ga0", "om", "a", "b", "phi", "psi", "I1", "I2", "I3", "d1", "ep1", "ep2", "alpha"),

  # Generate the initial step of Markov chain
  gen_init = function() {
      s1 <- rlogis(13, location = 0, scale = 1)
      s1
  },

  # Evaluate the log prior
  eval_lpr = function(params) {
    p1 = 0
    for (i in 1:13)
    {
      p1 <- p1 + dlogis(params[i], location = 0, scale = 1, log = TRUE)
    }
    p1
  },

  # Evaluate the log likelihood
  eval_ll = function(data, params) {

    eval_ll_cpp(data$obsdata, data$poly$matrix, data$dem, data$agegroup, params)
  }
)

```

# 3 Run the algorithms
# 3.1 Run the Bayesian Tools package
```{r}

# Standard (non-adaptive) Metropolis Hastings
settingsMH <- list(iterations = 1000000, nrChains = no_chains, thin = 10)
outMH <- runMCMC(bayesianSetup = bayesianSetup, sampler = "Metropolis", settings = settingsMH) # Standard function in Bayesian tools

# Adaptive Metropolis Hastings
settingsAM <- list(iterations = 1000000, nrChains = no_chains, thin = 10)
outAM <- runMCMC(bayesianSetup = bayesianSetup, sampler = "AM", settings = settingsAM) # Standard function in Bayesian tools
 
# Differential Evoluation with Snooker
settingsDezs <- list(iterations = 1000000, nrChains = no_chains, thin = 10)
outDezs <- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settingsDezs) # Standard function in Bayesian tools
# Look into this further, there are three chains per output 

```

# Run the ptmc package
```{r}

settingsPT <-  list(
  nrChains = 10,
  M = 10,
  iterations = 100000, 
  burn = 1,
  thin = 10,
  consoleUpdates = 100,
  P = 13,              
  adap_Cov = TRUE,
  adap_Cov_freq = 1,
  adap_Cov_burn = 10000,
  adap_Temp = TRUE,
  adap_Temp_freq = 1,
  Debug = FALSE
)

outPT <- ptmc_func(model, data, settingsPT)

```


# 4. Plots to understand convergence
#4.1 Likelihood 
```{r}

l <- length(outMH[[1]]$chain[,14])
lpMH <- data.frame(loglike=log(-as.vector(sapply(c(1:no_chains), function(x) outMH[[x]]$chain[,14]))))
lpMH$chain_no <- as.vector(sapply(c(1:no_chains), function(x) rep(toString(x), l)))
lpMH$sample_no <- rep(1:l,no_chains)
lpMH$mcmc <- rep("Metropolis", l*no_chains)

lpMH_conv <- lpMH %>% filter(sample_no>round(l/2))

p1<- ggplot(lpMH, aes(x = sample_no, y = loglike)) + 
  geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
  theme_minimal() +  scale_y_continuous(name="Log(-LogLikelihoood)")

p2<- ggplot(lpMH_conv, aes(x = sample_no, y = loglike)) + 
  geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
  theme_minimal() +  scale_y_continuous(name="Log(-LogLikelihoood)", limits=c(8.05, 8.1))

p <- grid.arrange(p1, p2,  top="Normal Metropolis-Hastings")

ggsave("./figs/llogMH.pdf", p)

```

```{r}

l <- length(outAM[[1]]$chain[,14])
lpAM <- data.frame(loglike=log(-as.vector(sapply(c(1:no_chains), function(x) outAM[[x]]$chain[,14]))))
lpAM$chain_no <- as.vector(sapply(c(1:no_chains), function(x) rep(toString(x), l)))
lpAM$sample_no <- rep(1:l,no_chains)
lpAM$mcmc <- rep("AM", l*no_chains)
lpAM_conv <- lpAM %>% filter(sample_no>round(l/2))

p1 <- ggplot(lpAM, aes(x = sample_no, y = loglike)) + 
  geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
  theme_minimal()  +  scale_y_continuous(name="Log(-LogLikelihoood)")

p2 <- ggplot(lpAM_conv, aes(x = sample_no, y = loglike)) + 
  geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
  theme_minimal() +  scale_y_continuous(name="Log(-LogLikelihoood)", limits=c(8.05, 8.1))


p <- grid.arrange(p1, p2,  top="Adaptive Metropolis-Hastings")

ggsave("./figs/llogAM.pdf", p)


```

```{r}

l <- length(outDezs[[1]][[3]][[1]][,14])
lpDezs <- data.frame(loglike=log(-as.vector(sapply(c(1:no_chains), function(x) outDezs[[x]][[3]][[1]][,14]))))
lpDezs$chain_no <- as.vector(sapply(c(1:no_chains), function(x) rep(toString(x), l)))
lpDezs$sample_no <- rep(1:l,no_chains)
lpDezs$mcmc <- rep("Dezs", l*no_chains)

lpDezs_conv <- lpDezs %>% filter(sample_no>round(l/2))

p1 <- ggplot(lpDezs, aes(x = sample_no, y = loglike)) + 
  geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
  theme_minimal()  +  scale_y_continuous(name="Log(-LogLikelihoood)")

p2 <- ggplot(lpDezs_conv, aes(x = sample_no, y = loglike)) + 
  geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
  theme_minimal() +  scale_y_continuous(name="Log(-LogLikelihoood)", limits=c(8.05, 8.1))

p <- grid.arrange(p1, p2,  top="Differential Evolaution with snooker update")

ggsave("./figs/llogDE.pdf", p)


```


```{r}


lpPT_conv <- outPT$lpost %>% filter(sample_no>round(10000/2))

p1 <- ggplot(outPT$lpost, aes(x = sample_no, y = log(-lpost))) + 
  geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
  theme_minimal()  +  scale_y_continuous(name="Log(-LogLikelihoood)")

p2 <- ggplot(lpPT_conv, aes(x = sample_no, y = log(-lpost))) + 
  geom_line(aes(color = chain_no), size = 0.2, alpha=0.8) +
  theme_minimal() +  scale_y_continuous(name="Log(-LogLikelihoood)", limits=c(8.05, 8.1))
 
p <- grid.arrange(p1, p2,  top="Parallel Tempering")

ggsave("./figs/llogPT.pdf", p)


```

```{r}

lpAll <- bind_rows(lpMH, lpAM, lpDezs,  outPT$lpost)

lpAll_conv <- lpAll %>% filter(sample_no>round(l/2))

p1 <- ggplot(lpAll, aes(x = sample_no, y = loglike)) + 
  geom_line(aes(color = c(mcmc,chain_no)), size = 0.2, alpha=0.8) +
  theme_minimal()

p2 <- ggplot(lpAll_conv, aes(x = sample_no, y = loglike)) + 
  geom_line(aes(color = mcmc), size = 0.2, alpha=0.8) +
  theme_minimal()

grid.arrange(p1, p2,  top="Parallel Tempering")

```



```{r}

ggsave("./figs/convPT.pdf", gelman.plot(outPT$mcmc))

```

```{r}



```